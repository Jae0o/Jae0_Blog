export const POST_EXAMPLE = {
  thumbnail:
    "https://firebasestorage.googleapis.com/v0/b/jae0-blog.appspot.com/o/image%2Fthumbnail%2Fc10081ee-1c10-4d5e-a39a-249e0825ffe9%2Fmain_image_c10081ee-1c10-4d5e-a39a-249e0825ffe9?alt=media&token=520a1d3b-a4cb-4610-9234-55fbd0860976",
  tag: ["JS", "React", "TS", "작업"],
  category: "BLOG",
  main: '<p><a href="https://www.jae0.co.kr/post/detail/74a66fd1-28fa-4260-bd41-adbb00425e78" rel="noopener noreferrer" target="_blank">지난 1부! 보러가기</a></p><p><br></p><p>이전에 Realtime DB에서 Firestore DB로 변경한 주요 이유 중 하나가 Infinity Scroll 기능 도입이었습니다.</p><p>이번 개선에서는 Firestore를 활용하여 본격적으로 Infinity Scroll 기능을 구현해보았습니다.</p><p><br></p><p><br></p><p><br></p><h2>Firestore 사전 준비!</h2><p><br></p><p>Firestore에서 Infinity Scroll을 도입하기 위해서는 API에서 <strong style="color: rgb(230, 0, 0);">페이지화</strong> 또는 <strong style="color: rgb(230, 0, 0);">쿼리 커서 기능</strong>을 제공해야 합니다.</p><p>Realtime DB의 경우 쿼리가 한정적이었기 때문에 Firestore를 도입하게 되었습니다.</p><p><br></p><p><img src="https://firebasestorage.googleapis.com/v0/b/jae0-blog.appspot.com/o/image%2FpostImage%2F1717255470672?alt=media&amp;token=46bbe7c8-7d58-471e-b4cf-5f3f9ebf946d"></p><p><br></p><p>Firestore를 이용한 페이지화 작업은 만만치 않은 작업이었습니다.</p><p>Firestore 라이브러리에서 제공하는 다양한 메서드를 활용하여 페이지화를 구현할 수 있습니다.</p><p><br></p><p>코드 예시와 같이 <strong style="color: rgb(230, 0, 0);">collection</strong> 메서드로 원하는 데이터 목록에 접근하고, <strong style="color: rgb(230, 0, 0);">orderBy</strong> 메서드로 정렬할 수 있습니다.</p><p>그리고 <strong style="color: rgb(230, 0, 0);">cursorId</strong>의 유무 에 따라 첫 호출인지 다음 페이지의 호출인지를 판별하여, 4개씩 데이터를 받아오는 구조로 구현하였습니다.</p><p><br></p><p>이 과정에서 queryRef 를 만들고, orderBy, where 등 다양한 Firestore 사용법을 학습하는 것이 쉽지 않았습니다.</p><p><br></p><p><br></p><p><br></p><h2>useInfinityQuery</h2><p><br></p><p>Tanstack Query의 useInfinityQuery를 활용하면 Infinity Scroll 구현 과정에서 발생할 수 있는 복잡한 부분을 효과적으로 해결할 수 있습니다.</p><p><br></p><p>특히 페이지별 데이터 요청 시 cursor 전달과 다음 페이지 존재 여부 확인 등의 복잡한 작업을 자동으로 처리해주 는 것이 큰 장점입니다.</p><p><br></p><p><img src="https://firebasestorage.googleapis.com/v0/b/jae0-blog.appspot.com/o/image%2FpostImage%2F1717255593067?alt=media&amp;token=8d58b7bc-03fa-46ea-90f2-6c42adbcd109"></p><p><br></p><p>코드 예시와 같이 <strong style="color: rgb(230, 0, 0);">initialPageParam</strong>에 초기 데이터 요청 시 사용할 cursor를, <strong style="color: rgb(230, 0, 0);">getNextPageParam</strong>에 다음 cursor를 생성하는 메서드를 전달하면 손쉽게 사용할 수 있습니다.</p><p><br></p><p>이후 useInfinityQuery가 반환하는 <strong style="color: rgb(230, 0, 0);">data</strong>는 2중 배열 형태로 저장되므로, 이 부분에 대한 별도의 처리가 필요합니다.</p><p>다음 페이지를 불러오는 경우에는 <strong style="color: rgb(230, 0, 0);">fetchNextPage</strong> 메서드를, 다음 페이지 존재 여부는 <strong style="color: rgb(230, 0, 0);">hasNextPage</strong> 값을 통해 확인할 수 있습니다.</p><p><br></p><p>이와 같이 useInfinityQuery를 활용하면 Infinity Scroll 구현 과정에서 발생할 수 있 는 복잡한 문제들을 효과적으로 해결할 수 있습니다.</p><p><br></p><p><br></p><p><br></p><h2>마지막으로 Observe!</h2><p><br></p><p>데이터 패치 작업을 모두 마무리하였습니다.</p><p>이제 어떤 시점에 다음 데이터를 불러와야 하는지에 대한 부분을 구현하는 것만 남았습니다.</p><p><br></p><p>별도의 버튼을 통해 사용자가 원할 때 추가 데이터를 패치하는 방법도 있지만, 이번에는 Infinity Scroll 기능을 구현하고 있기 때문에, 사용자가 마 지막 리스트를 확인하는 시점에 새로운 리스트를 자동으로 불러오도록 하였습니다.</p><p><br></p><p>이 과정을 쉽게 도와주는 기능이 바로 <strong style="color: rgb(230, 0, 0);">Intersection Observer</strong>입니다.</p><p><br></p><p><img src="https://firebasestorage.googleapis.com/v0/b/jae0-blog.appspot.com/o/image%2FpostImage%2F1717255801649?alt=media&amp;token=6a1ae253-977b-445d-8e92-0f706731b5e6"></p><p><br></p><p>사용법 이 복잡해 보이지만 실제로는 매우 간단합니다.</p><p>observer를 생성하고, 관찰 대상을 지정하며, 대상이 보일 때 실행할 콜백 함수를 전달하면 됩 니다.</p><p>그리고 더 이상 사용하지 않을 때는 연결을 해제하면 됩니다.</p><p>(Intersection Observer에 대한 자세한 내용은 <a href="https://www.notion.so/Observer-bb6944ddb8f94535aca6a91cb86709b4?pvs=21" rel="noopener noreferrer" target="_blank">이 링크</a>를 참고해 주세요.)</p><p><br></p><p>그런데 이번에는 추후 Framer Motion 라이브러리를 사용해 애니메이션을 개선할 예정이므로,</p><p>Framer Motion의 <strong style="color: rgb(230, 0, 0);">useInView hook</strong>을 활용하여 구현하였습니다.</p><p><br></p><p><img src="https://firebasestorage.googleapis.com/v0/b/jae0-blog.appspot.com/o/image%2FpostImage%2F1717255880295?alt=media&amp;token=e466ef25-2235-4708-ab4c-37bd2b5ec7e7"></p><p><br></p><p>짠! 이를 통해 ref가 전달된 div 요소가 viewport에 보이거나 보이지 않을 때의 상태를 쉽게 감지할 수 있으며,</p><p>그에 따라 <strong style="color: rgb(230, 0, 0);">fetchNextPage</strong>를 호출할 수 있습니다.</p><p><br></p><p><img src="https://firebasestorage.googleapis.com/v0/b/jae0-blog.appspot.com/o/image%2FpostImage%2F1717255902439?alt=media&amp;token=f42061f9-38d7-45ef-8f5b-db52e968183c"></p><p><br></p><p>결과적으로 사용 자가 리스트를 스크롤하면 ref가 전달된 div 요소가 화면에 나타나고, 그에 따라 새로운 데이터가 패치되는 것을 확인할 수 있습니다.</p><p><br></p><p>이를 통해 첫 페이지 접근 시 한 번에 너무 많은 데이터를 불러오는 것을 방지하고, 성능 향상을 꾀할 수 있습니다.</p><p><br></p><p><br></p><p><br></p><h2>최종 결과는?</h2><p><br></p><p>이번 개선 작업의 최종 결과는 기대했던 것만큼 좋지 않았습니다. Lighthouse 성능 점수가 오히려 감소 하는 모습을 보였습니다.</p><p><br></p><p><img src="https://firebasestorage.googleapis.com/v0/b/jae0-blog.appspot.com/o/image%2FpostImage%2F1717255950179?alt=media&amp;token=7ff5eb13-343b-4799-b997-afca19b26c3f"></p><p><br></p><p><img src="https://firebasestorage.googleapis.com/v0/b/jae0-blog.appspot.com/o/image%2FpostImage%2F1717667442352?alt=media&amp;token=3dd3fb04-ec6d-458e-bdb3-ce0df9fe35b2"></p><p><br></p><p>이 번 개선 작업에서는 Realtime Database에서 <span style="color: rgb(230, 0, 0);">Firestore로 데이터 저장소를 변경</span>했고,<span style="color: rgb(230, 0, 0);"> Infinity Scroll 기능</span>을 추가했습니다.</p><p>이러한 변경으로 인해 <strong style="color: rgb(230, 0, 0);">초기 렌더 링 속도( FCP )</strong>는 유지되었지만, 후속 <strong style="color: rgb(230, 0, 0);">데이터 로딩 속도( LCP )</strong>가 느려진 것으로 보입니 다.</p><p><br></p><p>그러나 Realtime Database만을 사용하는 것은 적절하지 않습니다.</p><p>용도에 맞는 데이터베이스를 선택하는 것이 중요하며, 이번 Firestore 도입은 그러한 측면에서 올바른 선택이었다고 생각합니다.</p><p>또한<strong style="color: rgb(230, 0, 0);"> Infinity Scroll 기능</strong>은 사용자 경험 향상에 기여할 수 있으므로, 성능적으로도 도움이 되었을 것 같습니다.</p><p><br></p><p>종합적으로 볼 때, 이번 개선 작업의 결과는 Lighthouse 점수만으로는 만족스럽지 않지만,</p><p>실제 사용자 경험 측면에서는 긍정적이고 좋은 개선 경험이었다고 생각합니다.</p><p>( 그래도 아쉽다… 🥹&nbsp;)</p>',
  title: "[ Blog ] 비동기 캐싱 & Infinity Scroll ( 2부 )",
  isPublic: true,
  updateAt: '"2024-06-06T14:52:15.445Z"',
  miniThumbnail:
    "https://firebasestorage.googleapis.com/v0/b/jae0-blog.appspot.com/o/image%2Fthumbnail%2Fc10081ee-1c10-4d5e-a39a-249e0825ffe9%2Fmini_c10081ee-1c10-4d5e-a39a-249e0825ffe9?alt=media&token=9fda7d9c-6437-413f-ac26-f43ca5874c46",
  createAt: '"2024-06-01T14:04:41.810Z"',
  id: "c10081ee-1c10-4d5e-a39a-249e0825ffe9",
};
